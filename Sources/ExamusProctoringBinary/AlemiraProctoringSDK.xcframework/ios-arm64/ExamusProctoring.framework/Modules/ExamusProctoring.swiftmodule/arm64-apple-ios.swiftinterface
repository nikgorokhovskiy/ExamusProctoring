// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.2 (swiftlang-5.7.2.135.5 clang-1400.0.29.51)
// swift-module-flags: -target arm64-apple-ios13.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name ExamusProctoring
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AVFoundation
import Combine
import Foundation
import Photos
import ReplayKit
import Swift
import UIKit
import _Concurrency
import _StringProcessing
public struct SendAgreementDTO : Swift.Decodable {
  public let status: Swift.String
  public init(from decoder: Swift.Decoder) throws
}
public enum InterruptReason {
  case upload
  case background
  case singleApp
  public static func == (a: ExamusProctoring.InterruptReason, b: ExamusProctoring.InterruptReason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension ExamusProctoring.ExamusSession {
  public func stopSession()
}
public protocol LoggerDelegate : AnyObject {
  func receivedError(_ error: ExamusProctoring.ExamusError)
}
public struct Permissions {
  public let cameraEnabled: Swift.Bool
  public let micEnabled: Swift.Bool
}
public enum PhotoType : Swift.String {
  case face
  case passport
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum RequiredPhotoType : Swift.String {
  case face
  case passport
  case faceAndPassport
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ExamusErrorType : Swift.Error {
  case apiError(code: Swift.Int)
  case networkError
  case decodeError
  case recordError
  case sessionError
  case pingError
  case logError
  case uploadVideoError
  case initSessionError(reason: ExamusProctoring.InitSessionErrorReason)
}
public enum InitSessionErrorReason {
  case invalidLink
  case doesNotExist
  case cantBeOpened
  public static func == (a: ExamusProctoring.InitSessionErrorReason, b: ExamusProctoring.InitSessionErrorReason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ExamusError : Swift.Error {
  public let message: Swift.String
  public let type: ExamusProctoring.ExamusErrorType
}
public struct MessageDTO : Swift.Decodable {
  public let id: Swift.Int?
  public let user: ExamusProctoring.UserDTO?
  public let type: Swift.String?
  public let image: Swift.String?
  public let message: Swift.String?
  public let warningType: Swift.String?
  public let warningMessage: Swift.String?
  public let protocolMessageType: Swift.String?
  public let protocolJsonData: ExamusProctoring.ProtocolJsonData?
  public let created: Swift.String?
  public let updated: Swift.String?
  public let isCyber: Swift.Bool?
  public let warningStart: Swift.String?
  public init(from decoder: Swift.Decoder) throws
}
public struct ProtocolJsonData : Swift.Decodable {
  public let examUrl: Swift.String?
  public init(from decoder: Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers final public class ExamusLibImpl {
  public static var instance: ExamusProctoring.Examus {
    get
  }
  @objc deinit
}
public struct SessionDTO : Swift.Decodable {
  public let id: Swift.Int?
  public let user: ExamusProctoring.UserDTO?
  public let created: Swift.String?
  public let updated: Swift.String?
  public let pipelineId: Swift.String?
  public let eula: Swift.String?
  public let proctorLevel: Swift.Int?
  public let canBeOpened: Swift.Bool?
  public let roomIsAvailable: Swift.Bool?
  public let canBeOpenedReason: Swift.String?
  public let isOpen: Swift.Bool?
  public let metadata: ExamusProctoring.MetadataDTO?
  public let closeToExpire: Swift.Bool?
  public let exam: ExamusProctoring.ExamInfoDTO?
  public let lastPing: Swift.String?
  public init(from decoder: Swift.Decoder) throws
}
public struct ExamInfoDTO : Swift.Decodable {
  public let id: Swift.Int?
  public let course: Swift.String?
  public let companyName: Swift.String?
  public let name: Swift.String?
  public let duration: Swift.Int?
  public init(from decoder: Swift.Decoder) throws
}
public struct MetadataDTO : Swift.Decodable {
  public let identificationMode: Swift.String
  public let monitorUrl: Swift.String
  public let siteUrl: Swift.String
  public let recorders: ExamusProctoring.RecorderDTO?
  public init(from decoder: Swift.Decoder) throws
}
public struct RecorderDTO : Swift.Decodable {
  public let mmm: ExamusProctoring.MMMDTO
  public init(from decoder: Swift.Decoder) throws
}
public struct MMMDTO : Swift.Decodable {
  public let url: Swift.String
  public let type: Swift.String
  public let bucket: Swift.String
  public let formData: [Swift.String : Swift.String]
  public init(from decoder: Swift.Decoder) throws
}
public protocol SessionStatusDelegate : AnyObject {
  func didInterruptSession(reason: ExamusProctoring.InterruptReason)
  func didResumeSession(reason: ExamusProctoring.InterruptReason)
  func didStopSession()
  func didFinishSession(leaveUrl: Foundation.URL?)
}
public protocol SessionPreparationDelegate : AnyObject {
  func didRevertPhotoCheck()
  func didStartExamFail(leaveUrl: Foundation.URL?)
  func didGetExamURL()
}
public protocol ExamusSession {
  var sessionId: Swift.String { get }
  func startSession(completion: @escaping (Swift.Result<ExamusProctoring.SessionDTO, ExamusProctoring.ExamusError>) -> Swift.Void)
  func startProctoring(delegate sessionDelegate: ExamusProctoring.SessionStatusDelegate, completion: @escaping (Swift.Result<Foundation.URL, ExamusProctoring.ExamusError>) -> Swift.Void)
  func stopSession(completion: @escaping (Swift.Result<ExamusProctoring.MessageDTO, ExamusProctoring.ExamusError>) -> Swift.Void)
  func getPhotoTypes(completion: @escaping (Swift.Result<ExamusProctoring.RequiredPhotoType, ExamusProctoring.ExamusError>) -> Swift.Void)
  func uploadPhoto(imageData: Foundation.Data, type: ExamusProctoring.PhotoType, completion: @escaping (Swift.Result<ExamusProctoring.MessageDTO, ExamusProctoring.ExamusError>) -> Swift.Void)
  func getUser(completion: @escaping (Swift.Result<ExamusProctoring.UserDTO, ExamusProctoring.ExamusError>) -> Swift.Void)
  func sendAgreement(completion: @escaping (Swift.Result<ExamusProctoring.SendAgreementDTO, ExamusProctoring.ExamusError>) -> Swift.Void)
  func getSessions(completion: @escaping (Swift.Result<[ExamusProctoring.SessionDTO], ExamusProctoring.ExamusError>) -> Swift.Void)
  func getAgreement() -> Swift.String
  func changeSingleAppModeState(for enabled: Swift.Bool, completion: @escaping (Swift.Result<Swift.Void, ExamusProctoring.ExamusError>) -> Swift.Void)
}
public protocol Examus {
  var session: ExamusProctoring.ExamusSession? { get }
  func initSession(with url: Foundation.URL, completion: @escaping (Swift.Result<Swift.Bool, ExamusProctoring.ExamusError>) -> Swift.Void)
  func setErrorHandler(delegate: ExamusProctoring.LoggerDelegate)
  func setLoggingEnabled(_ status: Swift.Bool)
  func checkPermissions(completion: @escaping (ExamusProctoring.Permissions) -> Swift.Void)
  func wasPermissionsDetermined() -> Swift.Bool
}
public struct UserDTO : Swift.Decodable {
  public let lastLogin: Swift.String?
  public let isActive: Swift.Bool?
  public let created: Swift.String?
  public let firstName: Swift.String?
  public let lastName: Swift.String?
  public let thirdName: Swift.String?
  public let updated: Swift.String?
  public let language: Swift.String?
  public let email: Swift.String?
  public let id: Swift.Int?
  public let isStaff: Swift.Bool?
  public let isProctor: Swift.Bool?
  public let isPersonalDataAgreementReceived: Swift.Bool?
  public init(from decoder: Swift.Decoder) throws
}
extension ExamusProctoring.InterruptReason : Swift.Equatable {}
extension ExamusProctoring.InterruptReason : Swift.Hashable {}
extension ExamusProctoring.PhotoType : Swift.Equatable {}
extension ExamusProctoring.PhotoType : Swift.Hashable {}
extension ExamusProctoring.PhotoType : Swift.RawRepresentable {}
extension ExamusProctoring.RequiredPhotoType : Swift.Equatable {}
extension ExamusProctoring.RequiredPhotoType : Swift.Hashable {}
extension ExamusProctoring.RequiredPhotoType : Swift.RawRepresentable {}
extension ExamusProctoring.InitSessionErrorReason : Swift.Equatable {}
extension ExamusProctoring.InitSessionErrorReason : Swift.Hashable {}
